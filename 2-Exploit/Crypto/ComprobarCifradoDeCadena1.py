#!/usr/bin/env python3


# curl -sL https://raw.githubusercontent.com/nipegun/pt-scripts/refs/heads/main/2-Exploit/Crypto/ComprobarCifradoDeCadena.py | python3 - "Cadena"

import sys
import itertools
import math
import random
import string

# -------------------------------------
#  Funciones ROT
# -------------------------------------

def fRotarCaracter(vChar, vK):
  if 'a' <= vChar <= 'z':
    return chr((ord(vChar) - 97 + vK) % 26 + 97)
  if 'A' <= vChar <= 'Z':
    return chr((ord(vChar) - 65 + vK) % 26 + 65)
  return vChar

def fAplicarROT(vTexto, vK):
  return ''.join(fRotarCaracter(c, vK) for c in vTexto)


# -------------------------------------
#  Atbash
# -------------------------------------

def fAplicarAtbash(vTexto):
  vOut = ""
  for c in vTexto:
    if 'a' <= c <= 'z':
      vOut += chr(122 - (ord(c) - 97))
    elif 'A' <= c <= 'Z':
      vOut += chr(90 - (ord(c) - 65))
    else:
      vOut += c
  return vOut


# -------------------------------------
#  Vigenère (limitado)
# -------------------------------------

def fAplicarVigenere(vTexto, vClave):
  vOut = ""
  vIdx = 0
  for c in vTexto:
    if c.isalpha():
      k = ord(vClave[vIdx % len(vClave)].lower()) - 97
      if c.islower():
        vOut += chr((ord(c) - 97 - k) % 26 + 97)
      else:
        vOut += chr((ord(c) - 65 - k) % 26 + 65)
      vIdx += 1
    else:
      vOut += c
  return vOut

def fGenerarClavesVigenere(vLongitud):
  for combo in itertools.product("abcdefghijklmnopqrstuvwxyz", repeat=vLongitud):
    yield "".join(combo)


# -------------------------------------
#  XOR 1 byte
# -------------------------------------

def fAplicarXOR1Byte(vTexto):
  vBytes = vTexto.encode("latin1")
  vResultados = []
  for vK in range(256):
    vDec = bytes([b ^ vK for b in vBytes])
    if all(32 <= c <= 126 for c in vDec):
      vResultados.append((vK, vDec.decode("latin1")))
  return vResultados


# -------------------------------------
#  XOR multi-byte (claves cortas)
# -------------------------------------

def fAplicarXORMultiByte(vTexto, vClave):
  vBytes = vTexto.encode("latin1")
  vOut = []
  for i, b in enumerate(vBytes):
    vOut.append(b ^ vClave[i % len(vClave)])
  return bytes(vOut).decode("latin1", errors="ignore")

def fGenerarClavesXORMultiByte(vLongitud):
  for combo in itertools.product(range(256), repeat=vLongitud):
    yield combo


# -------------------------------------
#  ASCII Shifting
# -------------------------------------

def fAsciiShift(vTexto, vShift):
  vOut = ""
  for c in vTexto:
    vOut += chr((ord(c) + vShift) % 256)
  return vOut


# -------------------------------------
#  Reverse helpers
# -------------------------------------

def fReverse(vTexto):
  return vTexto[::-1]


# -------------------------------------
#  Patrón estructural (sustitución)
# -------------------------------------

def fPatronEstructural(vTexto):
  vMapa = {}
  vNext = 0
  vOut = []
  for c in vTexto:
    if c.isalpha():
      if c not in vMapa:
        vMapa[c] = chr(65 + vNext)
        vNext += 1
      vOut.append(vMapa[c])
    else:
      vOut.append(c)
  return ''.join(vOut)


# -------------------------------------
#  Diccionario simple de puntuación
# -------------------------------------

vBigramas = {
  "th": 2, "he": 2, "in": 1.5, "er": 1.5, "an": 1.5,
  "re": 1.5, "on": 1.5, "at": 1.5, "en": 1.5, "nd": 1.5,
  "flag": 5, "{": 2, "}": 2
}

def fScoreTexto(vTexto):
  vTexto = vTexto.lower()
  vScore = 0
  for bg, val in vBigramas.items():
    vScore += vTexto.count(bg) * val
  return vScore


# -------------------------------------
#  Generación de sustitución aleatoria
# -------------------------------------

def fGenerarSustitucionAleatoria():
  vLetras = list(string.ascii_lowercase)
  random.shuffle(vLetras)
  return dict(zip(string.ascii_lowercase, vLetras))

def fAplicarSustitucion(vTexto, vMapa):
  vOut = ""
  for c in vTexto:
    if c.lower() in vMapa:
      vOut += vMapa[c.lower()]
    else:
      vOut += c
  return vOut


# -------------------------------------
#  Hill Climbing + Simulated Annealing
# -------------------------------------

def fCrackSustitucion(vTexto, vIter=5000):
  vTextoLimpio = ''.join(c for c in vTexto.lower())
  vBestMap = fGenerarSustitucionAleatoria()
  vBest = fAplicarSustitucion(vTextoLimpio, vBestMap)
  vBestScore = fScoreTexto(vBest)
  vMap = vBestMap.copy()

  for vI in range(vIter):
    a, b = random.sample(string.ascii_lowercase, 2)
    vMap[a], vMap[b] = vMap[b], vMap[a]

    vCand = fAplicarSustitucion(vTextoLimpio, vMap)
    vScore = fScoreTexto(vCand)

    vTemp = max(0.01, 1 - (vI / vIter))

    if vScore > vBestScore or random.random() < math.exp((vScore - vBestScore) / vTemp):
      vBestScore = vScore
      vBest = vCand
      vBestMap = vMap.copy()
    else:
      vMap[a], vMap[b] = vMap[b], vMap[a]

  return vBest, vBestMap, vBestScore


# -------------------------------------
#  Main
# -------------------------------------

if len(sys.argv) < 2:
  print("Uso: python3 script.py \"texto_cifrado\"")
  sys.exit(1)

vTexto = sys.argv[1]

print("=== ROT0–ROT25 ===")
for vK in range(26):
  print(f"ROT{vK:02d}: {fAplicarROT(vTexto, vK)}")

print("\n=== Atbash ===")
print(fAplicarAtbash(vTexto))

print("\n=== Vigenère (claves de 1 letra) ===")
for vClave in fGenerarClavesVigenere(1):
  print(f"Clave={vClave}: {fAplicarVigenere(vTexto, vClave)}")

print("\n=== XOR 1 byte ===")
vRes = fAplicarXOR1Byte(vTexto)
for vK, vDec in vRes:
  print(f"Key={vK:03d}: {vDec}")

print("\n=== ASCII Shift (-30 a +30) ===")
for vS in range(-30, 31):
  print(f"Shift {vS:+03d}: {fAsciiShift(vTexto, vS)}")

print("\n=== Reverse ===")
print(fReverse(vTexto))

print("\n=== Patrón de sustitución ===")
print(fPatronEstructural(vTexto))

print("\n=== Cracker de sustitución (hill-climbing) ===")
vDescifrado, vMapa, vScore = fCrackSustitucion(vTexto)
print("Resultado:")
print(vDescifrado)
print("Mapa usado:", vMapa)
print("Score:", vScore)
