#!/usr/bin/env python3


# curl -sL https://raw.githubusercontent.com/nipegun/pt-scripts/refs/heads/main/2-Exploit/Crypto/ComprobarCifradoDeCadenaSuper.py | python3 - "Cadena"

import sys
import itertools
import math
import random
import string

# -------------------------------------
#  Palabras clave para marcar resultados interesantes
# -------------------------------------

aPalabrasClave = [
  "bandera",
  "flag",
  "ctf",
  "hack",
  "epsilon",
  "h4ck",
  "clave",
  "key",
  "password"
]

def fEsInteresante(vTexto):
  vMin = vTexto.lower()
  for vPalabra in aPalabrasClave:
    if vPalabra in vMin:
      return True
  return False


# -------------------------------------
#  ROT alfabético clásico (ya lo tenías)
# -------------------------------------

def fRotarCaracter(vChar, vK):
  if 'a' <= vChar <= 'z':
    return chr((ord(vChar) - 97 + vK) % 26 + 97)
  if 'A' <= vChar <= 'Z':
    return chr((ord(vChar) - 65 + vK) % 26 + 65)
  return vChar

def fAplicarROT(vTexto, vK):
  return ''.join(fRotarCaracter(c, vK) for c in vTexto)


# -------------------------------------
#  Atbash
# -------------------------------------

def fAplicarAtbash(vTexto):
  vOut = ""
  for c in vTexto:
    if 'a' <= c <= 'z':
      vOut += chr(122 - (ord(c) - 97))
    elif 'A' <= c <= 'Z':
      vOut += chr(90 - (ord(c) - 65))
    else:
      vOut += c
  return vOut


# -------------------------------------
#  Vigenère (mismo estilo que tu script original)
# -------------------------------------

def fAplicarVigenere(vTexto, vClave):
  vOut = ""
  vIdx = 0
  for c in vTexto:
    if c.isalpha():
      vK = ord(vClave[vIdx % len(vClave)].lower()) - 97
      if c.islower():
        vOut += chr((ord(c) - 97 - vK) % 26 + 97)
      else:
        vOut += chr((ord(c) - 65 - vK) % 26 + 65)
      vIdx += 1
    else:
      vOut += c
  return vOut

def fGenerarClavesVigenere(vLongitud):
  vAlfabeto = "abcdefghijklmnopqrstuvwxyz"
  for vCombo in itertools.product(vAlfabeto, repeat=vLongitud):
    yield "".join(vCombo)


# -------------------------------------
#  ROT47 (ASCII 33..126)
# -------------------------------------

def fAplicarROT47(vTexto):
  vOut = ""
  for c in vTexto:
    vOrd = ord(c)
    if 33 <= vOrd <= 126:
      vOut += chr(33 + ((vOrd - 33 + 47) % 94))
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT5 (solo dígitos 0-9)
# -------------------------------------

def fAplicarROT5(vTexto):
  vOut = ""
  for c in vTexto:
    if '0' <= c <= '9':
      vOut += chr((ord(c) - 48 + 5) % 10 + 48)
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT18 = ROT13 (letras) + ROT5 (dígitos)
# -------------------------------------

def fAplicarROT18(vTexto):
  vOut = ""
  for c in vTexto:
    if 'a' <= c <= 'z' or 'A' <= c <= 'Z':
      vOut += fRotarCaracter(c, 13)
    elif '0' <= c <= '9':
      vOut += chr((ord(c) - 48 + 5) % 10 + 48)
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT62-A  (a-z A-Z 0-9)
# -------------------------------------

vAlfabeto62A = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

def fAplicarROT62A(vTexto, vK):
  vOut = ""
  vK = vK % len(vAlfabeto62A)
  for c in vTexto:
    if c in vAlfabeto62A:
      vIdx = vAlfabeto62A.index(c)
      vOut += vAlfabeto62A[(vIdx + vK) % len(vAlfabeto62A)]
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT62-B  (0-9 a-z A-Z)
# -------------------------------------

vAlfabeto62B = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

def fAplicarROT62B(vTexto, vK):
  vOut = ""
  vK = vK % len(vAlfabeto62B)
  for c in vTexto:
    if c in vAlfabeto62B:
      vIdx = vAlfabeto62B.index(c)
      vOut += vAlfabeto62B[(vIdx + vK) % len(vAlfabeto62B)]
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT ASCII generalizado (por rango)
#  Ejemplo: rango 33..126 (como ROT47 pero con K variable)
# -------------------------------------

def fAplicarROTAsciiRango(vTexto, vK, vInicio=33, vFin=126):
  vOut = ""
  vK = vK % (vFin - vInicio + 1)
  for c in vTexto:
    vOrd = ord(c)
    if vInicio <= vOrd <= vFin:
      vOut += chr(vInicio + ((vOrd - vInicio + vK) % (vFin - vInicio + 1)))
    else:
      vOut += c
  return vOut


# -------------------------------------
#  ROT256 (byte completo 0..255)
# -------------------------------------

def fAplicarROT256(vTexto, vK):
  vOutBytes = []
  vK = vK % 256
  for c in vTexto.encode("latin1", errors="ignore"):
    vOutBytes.append((c + vK) % 256)
  return bytes(vOutBytes).decode("latin1", errors="ignore")


# -------------------------------------
#  XOR 1 byte
# -------------------------------------

def fAplicarXOR1Byte(vTexto):
  vBytes = vTexto.encode("latin1", errors="ignore")
  vResultados = []
  for vK in range(256):
    vDec = bytes([b ^ vK for b in vBytes])
    try:
      vDecStr = vDec.decode("latin1")
    except:
      continue
    if all(32 <= ord(c) <= 126 for c in vDecStr):
      vResultados.append((vK, vDecStr))
  return vResultados


# -------------------------------------
#  XOR multi-byte (clave corta)
# -------------------------------------

def fAplicarXORMultiByte(vTexto, aClaveBytes):
  vBytes = vTexto.encode("latin1", errors="ignore")
  vOut = []
  vLenClave = len(aClaveBytes)
  for i, b in enumerate(vBytes):
    vOut.append(b ^ aClaveBytes[i % vLenClave])
  return bytes(vOut).decode("latin1", errors="ignore")


# -------------------------------------
#  ASCII Shift (suma/resta a ord)
# -------------------------------------

def fAsciiShift(vTexto, vShift):
  vOut = ""
  for c in vTexto:
    vOut += chr((ord(c) + vShift) % 256)
  return vOut


# -------------------------------------
#  Reverse
# -------------------------------------

def fReverse(vTexto):
  return vTexto[::-1]


# -------------------------------------
#  Patrón estructural (sustitución)
# -------------------------------------

def fPatronEstructural(vTexto):
  vMapa = {}
  vNext = 0
  vOut = []
  for c in vTexto:
    if c.isalpha():
      if c not in vMapa:
        vMapa[c] = chr(65 + vNext)
        vNext += 1
      vOut.append(vMapa[c])
    else:
      vOut.append(c)
  return ''.join(vOut)


# -------------------------------------
#  Scoring simple por bigramas / palabras
# -------------------------------------

vBigramas = {
  "th": 2.0,
  "he": 2.0,
  "in": 1.5,
  "er": 1.5,
  "an": 1.5,
  "re": 1.5,
  "on": 1.5,
  "at": 1.5,
  "en": 1.5,
  "nd": 1.5,
  "flag": 5.0,
  "bandera": 6.0
}

def fScoreTexto(vTexto):
  vTextoLower = vTexto.lower()
  vScore = 0.0
  for vBg, vVal in vBigramas.items():
    vScore += vTextoLower.count(vBg) * vVal
  return vScore


# -------------------------------------
#  Sustitución monoalfabética + hill-climbing
# -------------------------------------

def fGenerarSustitucionAleatoria():
  aLetras = list(string.ascii_lowercase)
  random.shuffle(aLetras)
  return dict(zip(string.ascii_lowercase, aLetras))

def fAplicarSustitucion(vTexto, vMapa):
  vOut = ""
  for c in vTexto:
    vLower = c.lower()
    if vLower in vMapa and c.isalpha():
      vSub = vMapa[vLower]
      if c.isupper():
        vOut += vSub.upper()
      else:
        vOut += vSub
    else:
      vOut += c
  return vOut

def fCrackSustitucion(vTexto, vIter=5000):
  vTextoLimpio = ''.join(c for c in vTexto if c.isalpha() or c == ' ')
  if not vTextoLimpio:
    return vTexto, {}, 0.0

  vBestMap = fGenerarSustitucionAleatoria()
  vBest = fAplicarSustitucion(vTextoLimpio, vBestMap)
  vBestScore = fScoreTexto(vBest)
  vMapaActual = dict(vBestMap)

  for vI in range(vIter):
    a, b = random.sample(string.ascii_lowercase, 2)
    vMapaActual[a], vMapaActual[b] = vMapaActual[b], vMapaActual[a]

    vCand = fAplicarSustitucion(vTextoLimpio, vMapaActual)
    vScore = fScoreTexto(vCand)
    vTemp = max(0.01, 1.0 - (vI / float(vIter)))

    if vScore > vBestScore or random.random() < math.exp((vScore - vBestScore) / vTemp):
      vBestScore = vScore
      vBest = vCand
      vBestMap = dict(vMapaActual)
    else:
      vMapaActual[a], vMapaActual[b] = vMapaActual[b], vMapaActual[a]

  return vBest, vBestMap, vBestScore


# -------------------------------------
#  Main
# -------------------------------------

if len(sys.argv) < 2:
  print("Uso: python3 ComprobarCifradoDeCadenaSuper.py \"texto_cifrado\"")
  sys.exit(1)

vTexto = sys.argv[1]

# ROT alfabético 0-25
print("=== ROT0–ROT25 (alfabético) ===")
for vK in range(26):
  print(f"ROT{vK:02d}: {fAplicarROT(vTexto, vK)}")

# Atbash
print("\n=== Atbash ===")
print(fAplicarAtbash(vTexto))

# Vigenère fuerza bruta limitada
print("\n=== Vigenère (claves de 1 letra a-z) ===")
for vClave in fGenerarClavesVigenere(1):
  print(f"Clave={vClave}: {fAplicarVigenere(vTexto, vClave)}")

print("\n=== Vigenère (claves de 2 letras, primeras 200) ===")
vCont = 0
for vClave in fGenerarClavesVigenere(2):
  print(f"Clave={vClave}: {fAplicarVigenere(vTexto, vClave)}")
  vCont += 1
  if vCont >= 200:
    print("... truncado Vigenère 2 letras para evitar miles de líneas.")
    break

# ROT47
print("\n=== ROT47 ===")
print(fAplicarROT47(vTexto))

# ROT5 y ROT18
print("\n=== ROT5 (solo dígitos) ===")
print(fAplicarROT5(vTexto))

print("\n=== ROT18 (ROT13+ROT5) ===")
print(fAplicarROT18(vTexto))

# ROT62-A y ROT62-B (solo mostramos clave y salida)
print("\n=== ROT62-A (a-zA-Z0-9) para K=0..61 ===")
for vK in range(62):
  vOut = fAplicarROT62A(vTexto, vK)
  if fEsInteresante(vOut):
    print(f"K={vK:02d}: {vOut}")

print("\n=== ROT62-B (0-9a-zA-Z) para K=0..61 ===")
for vK in range(62):
  vOut = fAplicarROT62B(vTexto, vK)
  if fEsInteresante(vOut):
    print(f"K={vK:02d}: {vOut}")

# ROT ASCII rango general (ej: 33..126)
print("\n=== ROT ASCII rango 33–126 (K=1..93, solo interesantes) ===")
for vK in range(1, 94):
  vOut = fAplicarROTAsciiRango(vTexto, vK, 33, 126)
  if fEsInteresante(vOut):
    print(f"K={vK:02d}: {vOut}")

# XOR 1 byte
print("\n=== XOR 1 byte (0–255, solo salidas imprimibles) ===")
vResXOR = fAplicarXOR1Byte(vTexto)
for vK, vDec in vResXOR:
  if fEsInteresante(vDec):
    print(f"Key={vK:03d}: {vDec}")
  else:
    print(f"Key={vK:03d}: {vDec}")

# ASCII Shift
print("\n=== ASCII Shift (-30 a +30) ===")
for vS in range(-30, 31):
  vOut = fAsciiShift(vTexto, vS)
  print(f"Shift {vS:+03d}: {vOut}")

# Reverse
print("\n=== Reverse ===")
print(fReverse(vTexto))

# Patrón estructural
print("\n=== Patrón de sustitución monoalfabética ===")
print(fPatronEstructural(vTexto))

# ROT256 (recorremos 0..255, pero imprimimos solo salidas interesantes)
print("\n=== ROT256 (0..255, solo salidas interesantes) ===")
for vK in range(256):
  vOut = fAplicarROT256(vTexto, vK)
  if fEsInteresante(vOut):
    print(f"ROT256 K={vK:03d}: {vOut}")

# Cracker de sustitución
print("\n=== Cracker de sustitución (hill-climbing) ===")
vDescifrado, vMapa, vScore = fCrackSustitucion(vTexto)
print("Resultado aproximado:")
print(vDescifrado)
print("Mapa usado:", vMapa)
print("Score:", vScore)
