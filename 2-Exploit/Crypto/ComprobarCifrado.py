#!/usr/bin/env python3

import sys
import string
import itertools

# -------------------------------------
#  Funciones ROT
# -------------------------------------

def fRotarCaracter(vChar, vK):
  if 'a' <= vChar <= 'z':
    return chr((ord(vChar) - 97 + vK) % 26 + 97)
  if 'A' <= vChar <= 'Z':
    return chr((ord(vChar) - 65 + vK) % 26 + 65)
  return vChar

def fAplicarROT(vTexto, vK):
  return ''.join(fRotarCaracter(c, vK) for c in vTexto)


# -------------------------------------
#  Atbash
# -------------------------------------

def fAplicarAtbash(vTexto):
  vOut = ""
  for c in vTexto:
    if 'a' <= c <= 'z':
      vOut += chr(122 - (ord(c) - 97))
    elif 'A' <= c <= 'Z':
      vOut += chr(90 - (ord(c) - 65))
    else:
      vOut += c
  return vOut


# -------------------------------------
#  Vigenère con claves pequeñas
#  (fuerza bruta limitada)
# -------------------------------------

def fAplicarVigenere(vTexto, vClave):
  vOut = ""
  vIdx = 0
  for c in vTexto:
    if c.isalpha():
      k = ord(vClave[vIdx % len(vClave)].lower()) - 97
      if c.islower():
        vOut += chr((ord(c) - 97 - k) % 26 + 97)
      else:
        vOut += chr((ord(c) - 65 - k) % 26 + 65)
      vIdx += 1
    else:
      vOut += c
  return vOut

def fGenerarClavesVigenere(vLongitud):
  vAlfabeto = "abcdefghijklmnopqrstuvwxyz"
  for combo in itertools.product(vAlfabeto, repeat=vLongitud):
    yield "".join(combo)


# -------------------------------------
#  Sustitución monoalfabética (solo análisis)
#  Esto NO descifra automáticamente.
#  Muestra el patrón estructural (ejemplo: ABCA...)
# -------------------------------------

def fPatronEstructural(vTexto):
  vMapa = {}
  vNext = 0
  vOut = []
  for c in vTexto:
    if c.isalpha():
      if c not in vMapa:
        vMapa[c] = chr(65 + vNext)
        vNext += 1
      vOut.append(vMapa[c])
    else:
      vOut.append(c)
  return ''.join(vOut)


# -------------------------------------
#  Main
# -------------------------------------

if len(sys.argv) < 2:
  print("Uso: python3 decodificador.py \"texto_cifrado\"")
  sys.exit(1)

vTexto = sys.argv[1]

print("=== ROT0–ROT25 ===")
for vK in range(26):
  print(f"ROT{vK:02d}: {fAplicarROT(vTexto, vK)}")

print("\n=== Atbash ===")
print(fAplicarAtbash(vTexto))

print("\n=== Vigenère (fuerza bruta limitada) ===")
print("Clave longitud 1 (a-z):")
for vClave in fGenerarClavesVigenere(1):
  vDec = fAplicarVigenere(vTexto, vClave)
  print(f"Clave={vClave}: {vDec}")

print("\nClave longitud 2 (aa-zz):")
# LIMITAMOS POR RAZONES DE TIEMPO: solo primeras 200 claves
vCont = 0
for vClave in fGenerarClavesVigenere(2):
  print(f"Clave={vClave}: {fAplicarVigenere(vTexto, vClave)}")
  vCont += 1
  if vCont >= 200:
    print("... truncado para evitar miles de líneas. Amplía según lo necesites.")
    break

print("\n=== Patrón de sustitución monoalfabética ===")
print("Patrón estructural encontrado (no es el descifrado, solo la estructura):")
print(fPatronEstructural(vTexto))
